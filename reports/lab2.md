# Chapter 4 s地址空间

## 编程作业

1. 重写sys_get_time和sys_task_info

    原来的sys_get_time和sys_task_info无法在chapter 4正确执行是因为用户使用这两个系统调用时切换到了内核地址空间，传入的指针参数就失效了，需要把指针参数转化为真正的物理地址。这里为了方便，我实现了copy_to_user和copy_from_user（src/mm/page_table.rs 227-275）从用户和内核地址空间之间拷贝数据。

2. 实现mmap和munmap

    mmap的实现方式比较简单，直接在MemorySet的areas里加上一个MapArea即可（见MemorySet.map_area）。

    munmap实现比较复杂，这里使用了区间树（IntervalMap）找到重叠的一连串连续的MapArea，然后释放里面的虚拟页，注意两端MapArea的处理，需要分裂为多个MapArea。

## 问答作业

1. SV39分页机制PTE组成

    目前在实验中用到的两个主要字段：[53:10]是物理页号，[7:0]是标志位。标志位控制页的读/写/执行权限、页的访问权限以及Valid、Dirty、Accessed等访问信息。

2. 缺页

    mmap系统调用映射了新的虚拟内存但是还没有真正建立这部分内存和物理内存之间的映射，访问这些地址会触发缺页。

    fork创建子进程会复制父进程的地址空间，假如采用COW机制，会在子进程写入父进程只读的地址时会触发缺页异常。

    在异常发生时，转到stevc指向的处理函数入口(实验中是trap_handle)，然后根据scase寄存器中的值判断异常产生的原因，同时在stval中存放了异常信息（缺页异常下是导致异常发生的地址）。

    Lazy策略可以提高内存利用率，方便库函数等代码在进程间共享。

    10G的连续内存至少需要2M个PTE，每个PTE占用8byte，则页表至少需要16MB以上的内存空间。

    Lazy策略的设想：在tcb中保存代码段的起始VA，当pc执行代码段时触发page fault再从磁盘导入代码段。

    页面失效，在PTE中将Valid字段设置为0.

3. 双页表与单页表

    单页表在trap时似乎不切换页表，在切换用户进程时通过切换satp寄存器切换页表。

    单页表情况下，设置PTE中的U字段可以限制用户对内核页的访问。

    单页表实现简单，只需将虚拟地址空间划分为用户空间和内核空间。

    双页表在trap和在内态态调度进程时切换satp中的页表基址。实现单页表，只考虑在内核切换进程时切换页表。
